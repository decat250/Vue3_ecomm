import { h, ref, toRef, computed, defineComponent, provide, inject, watchEffect } from 'vue';
import { createTreeMate } from 'treemate';
import { useCompitable, useMergedState } from 'vooks';
import { useConfig, useTheme } from '../../_mixins';
import { call } from '../../_utils';
import { itemRenderer } from './utils';
import { menuLight } from '../styles';
import style from './styles/index.cssr';
import { layoutSiderInjectionKey } from '../../layout/src/interface';
import { useCheckDeprecated } from './useCheckDeprecated';
import { menuInjectionKey } from './context';
const menuProps = Object.assign(Object.assign({}, useTheme.props), { options: {
        type: Array,
        default: () => []
    }, collapsed: {
        type: Boolean,
        default: undefined
    }, collapsedWidth: {
        type: Number,
        default: 48
    }, iconSize: {
        type: Number,
        default: 20
    }, collapsedIconSize: {
        type: Number,
        default: 24
    }, rootIndent: Number, indent: {
        type: Number,
        default: 32
    }, labelField: {
        type: String,
        default: 'label'
    }, keyField: {
        type: String,
        default: 'key'
    }, childrenField: {
        type: String,
        default: 'children'
    }, defaultExpandAll: Boolean, defaultExpandedKeys: Array, expandedKeys: Array, value: [String, Number], defaultValue: {
        type: [String, Number],
        default: null
    }, mode: {
        type: String,
        default: 'vertical'
    }, watchProps: {
        type: Array,
        default: undefined
    }, disabled: Boolean, inverted: Boolean, 'onUpdate:expandedKeys': [Function, Array], onUpdateExpandedKeys: [Function, Array], onUpdateValue: [Function, Array], 'onUpdate:value': [Function, Array], expandIcon: Function, renderIcon: Function, renderLabel: Function, renderExtra: Function, 
    /** TODO: deprecate it */
    dropdownPlacement: {
        type: String,
        default: 'bottom'
    }, dropdownProps: Object, accordion: Boolean, 
    // deprecated
    items: Array, onOpenNamesChange: [Function, Array], onSelect: [Function, Array], onExpandedNamesChange: [Function, Array], expandedNames: Array, defaultExpandedNames: Array });
export default defineComponent({
    name: 'Menu',
    props: menuProps,
    setup(props) {
        if (process.env.NODE_ENV !== 'production') {
            useCheckDeprecated(props);
        }
        const { mergedClsPrefixRef } = useConfig(props);
        const themeRef = useTheme('Menu', '-menu', style, menuLight, props, mergedClsPrefixRef);
        const layoutSider = inject(layoutSiderInjectionKey, null);
        const mergedCollapsedRef = computed(() => {
            var _a;
            const { collapsed } = props;
            if (collapsed !== undefined)
                return collapsed;
            if (layoutSider) {
                const { collapseModeRef, collapsedRef } = layoutSider;
                if (collapseModeRef.value === 'width') {
                    return (_a = collapsedRef.value) !== null && _a !== void 0 ? _a : false;
                }
            }
            return false;
        });
        const treeMateRef = computed(() => {
            const { keyField, childrenField } = props;
            return createTreeMate(props.items || props.options, {
                getChildren(node) {
                    return node[childrenField];
                },
                getKey(node) {
                    var _a;
                    return (_a = node[keyField]) !== null && _a !== void 0 ? _a : node.name;
                }
            });
        });
        const treeKeysLevelOneRef = computed(() => new Set(treeMateRef.value.treeNodes.map((e) => e.key)));
        const { watchProps } = props;
        const uncontrolledValueRef = ref(null);
        if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultValue')) {
            watchEffect(() => {
                uncontrolledValueRef.value = props.defaultValue;
            });
        }
        else {
            uncontrolledValueRef.value = props.defaultValue;
        }
        const controlledValueRef = toRef(props, 'value');
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        const uncontrolledExpandedKeysRef = ref([]);
        const initUncontrolledExpandedKeys = () => {
            uncontrolledExpandedKeysRef.value = props.defaultExpandAll
                ? treeMateRef.value.getNonLeafKeys()
                : props.defaultExpandedNames ||
                    props.defaultExpandedKeys ||
                    treeMateRef.value.getPath(mergedValueRef.value, {
                        includeSelf: false
                    }).keyPath;
        };
        if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultExpandedKeys')) {
            watchEffect(initUncontrolledExpandedKeys);
        }
        else {
            initUncontrolledExpandedKeys();
        }
        const controlledExpandedKeysRef = useCompitable(props, [
            'expandedNames',
            'expandedKeys'
        ]);
        const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);
        const tmNodesRef = computed(() => treeMateRef.value.treeNodes);
        const activePathRef = computed(() => {
            return treeMateRef.value.getPath(mergedValueRef.value).keyPath;
        });
        provide(menuInjectionKey, {
            props,
            mergedCollapsedRef,
            mergedThemeRef: themeRef,
            mergedValueRef,
            mergedExpandedKeysRef,
            activePathRef,
            mergedClsPrefixRef,
            isHorizontalRef: computed(() => props.mode === 'horizontal'),
            invertedRef: toRef(props, 'inverted'),
            doSelect,
            toggleExpand
        });
        function doSelect(value, item) {
            const { 'onUpdate:value': _onUpdateValue, onUpdateValue, onSelect } = props;
            if (onUpdateValue) {
                call(onUpdateValue, value, item);
            }
            if (_onUpdateValue) {
                call(_onUpdateValue, value, item);
            }
            if (onSelect) {
                call(onSelect, value, item);
            }
            uncontrolledValueRef.value = value;
        }
        function doUpdateExpandedKeys(value) {
            const { 'onUpdate:expandedKeys': _onUpdateExpandedKeys, onUpdateExpandedKeys, onExpandedNamesChange, onOpenNamesChange } = props;
            if (_onUpdateExpandedKeys) {
                call(_onUpdateExpandedKeys, value);
            }
            if (onUpdateExpandedKeys) {
                call(onUpdateExpandedKeys, value);
            }
            // deprecated
            if (onExpandedNamesChange) {
                call(onExpandedNamesChange, value);
            }
            if (onOpenNamesChange) {
                call(onOpenNamesChange, value);
            }
            uncontrolledExpandedKeysRef.value = value;
        }
        function toggleExpand(key) {
            const currentExpandedKeys = Array.from(mergedExpandedKeysRef.value);
            const index = currentExpandedKeys.findIndex((expanededKey) => expanededKey === key);
            if (~index) {
                currentExpandedKeys.splice(index, 1);
            }
            else {
                if (props.accordion) {
                    if (treeKeysLevelOneRef.value.has(key)) {
                        const closeKeyIndex = currentExpandedKeys.findIndex((e) => treeKeysLevelOneRef.value.has(e));
                        if (closeKeyIndex > -1) {
                            currentExpandedKeys.splice(closeKeyIndex, 1);
                        }
                    }
                }
                currentExpandedKeys.push(key);
            }
            doUpdateExpandedKeys(currentExpandedKeys);
        }
        return {
            mergedClsPrefix: mergedClsPrefixRef,
            controlledExpandedKeys: controlledExpandedKeysRef,
            uncontrolledExpanededKeys: uncontrolledExpandedKeysRef,
            mergedExpandedKeys: mergedExpandedKeysRef,
            uncontrolledValue: uncontrolledValueRef,
            mergedValue: mergedValueRef,
            activePath: activePathRef,
            tmNodes: tmNodesRef,
            mergedTheme: themeRef,
            mergedCollapsed: mergedCollapsedRef,
            cssVars: computed(() => {
                const { inverted } = props;
                const { common: { cubicBezierEaseInOut }, self } = themeRef.value;
                const { borderRadius, borderColorHorizontal, fontSize, itemHeight, dividerColor } = self;
                const vars = {
                    '--n-divider-color': dividerColor,
                    '--n-bezier': cubicBezierEaseInOut,
                    '--n-font-size': fontSize,
                    '--n-border-color-horizontal': borderColorHorizontal,
                    '--n-border-radius': borderRadius,
                    '--n-item-height': itemHeight
                };
                if (inverted) {
                    vars['--n-group-text-color'] = self.groupTextColorInverted;
                    vars['--n-color'] = self.colorInverted;
                    vars['--n-item-text-color'] = self.itemTextColorInverted;
                    vars['--n-arrow-color'] = self.arrowColorInverted;
                    vars['--n-arrow-color-hover'] = self.arrowColorHoverInverted;
                    vars['--n-arrow-color-active'] = self.arrowColorActiveInverted;
                    vars['--n-arrow-color-child-active'] =
                        self.arrowColorChildActiveInverted;
                    vars['--n-item-icon-color'] = self.itemIconColorInverted;
                    vars['--n-item-text-color-hover'] = self.itemTextColorHoverInverted;
                    vars['--n-item-icon-color-hover'] = self.itemIconColorHoverInverted;
                    vars['--n-item-text-color-active'] = self.itemTextColorActiveInverted;
                    vars['--n-item-icon-color-active'] = self.itemIconColorActiveInverted;
                    vars['--n-item-icon-color-collapsed'] =
                        self.itemIconColorCollapsedInverted;
                    vars['--n-item-color-active'] = self.itemColorActiveInverted;
                    vars['--n-item-color-active-collapsed'] =
                        self.itemColorActiveCollapsedInverted;
                    vars['--n-item-text-color-child-active'] =
                        self.itemTextColorChildActiveInverted;
                    vars['--n-item-icon-color-child-active'] =
                        self.itemIconColorChildActiveInverted;
                }
                else {
                    vars['--n-group-text-color'] = self.groupTextColor;
                    vars['--n-color'] = self.color;
                    vars['--n-item-text-color'] = self.itemTextColor;
                    vars['--n-arrow-color'] = self.arrowColor;
                    vars['--n-arrow-color-hover'] = self.arrowColorHover;
                    vars['--n-arrow-color-active'] = self.arrowColorActive;
                    vars['--n-arrow-color-child-active'] = self.arrowColorChildActive;
                    vars['--n-item-icon-color'] = self.itemIconColor;
                    vars['--n-item-text-color-hover'] = self.itemTextColorHover;
                    vars['--n-item-icon-color-hover'] = self.itemIconColorHover;
                    vars['--n-item-text-color-active'] = self.itemTextColorActive;
                    vars['--n-item-icon-color-active'] = self.itemIconColorActive;
                    vars['--n-item-icon-color-collapsed'] = self.itemIconColorCollapsed;
                    vars['--n-item-color-active'] = self.itemColorActive;
                    vars['--n-item-color-active-collapsed'] =
                        self.itemColorActiveCollapsed;
                    vars['--n-item-text-color-child-active'] =
                        self.itemTextColorChildActive;
                    vars['--n-item-icon-color-child-active'] =
                        self.itemIconColorChildActive;
                }
                return vars;
            })
        };
    },
    render() {
        const { mergedClsPrefix, mode } = this;
        return (h("div", { role: mode === 'horizontal' ? 'menubar' : 'menu', class: [
                `${mergedClsPrefix}-menu`,
                `${mergedClsPrefix}-menu--${mode}`,
                this.mergedCollapsed && `${mergedClsPrefix}-menu--collapsed`
            ], style: this.cssVars }, this.tmNodes.map((tmNode) => itemRenderer(tmNode, this.$props))));
    }
});
